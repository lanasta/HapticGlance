using System;
using System.Diagnostics;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Windows;
using System.Threading;
using System.ComponentModel;
using System.IO.Ports;
using System.Windows.Threading;
using System.Windows.Media;

namespace ForceReaderStudy
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        static string ipAddr = "192.168.1.1";
        static int port = 49152;
        Response resp;
        Force force;
        Force hapticForce;

        BackgroundWorker worker;

        bool workerOn = false;
        IPEndPoint ep;

        bool bendBottomOut = false;
        double bendBottomOutThresh = 20.5;

        int selectedFrictionValue = 1;
        //low values: easy movement, high values: frictional movement with bottom out vibrations
        //minimal effort vs a lot of effort pressing (fz) could mean different things
        bool messageExists = true; //if false, should not feel any feedback when pressing left
        bool itemsInSchedule = true; //if false, should not feel any feedback pressing down
        bool newEmails = true; //if true, add vibrotactile ticks
        bool missedCallsExist = true; //if true, feedback pressing right


        public MainWindow()
        {
            InitializeComponent();

            resp = new Response();
            force = new Force(selectedFrictionValue, false);
            hapticForce = force;

            worker = new BackgroundWorker();
            worker.DoWork += new DoWorkEventHandler(worker_doWork);
            worker.ProgressChanged += new ProgressChangedEventHandler
                    (worker_ProgressChanged);
            worker.RunWorkerCompleted += new RunWorkerCompletedEventHandler
                    (worker_RunWorkerCompleted);
            worker.WorkerReportsProgress = true;
            worker.WorkerSupportsCancellation = true;
            client = new UdpClient();
            ep = new IPEndPoint(IPAddress.Parse(ipAddr), port); // endpoint where server is listening
            client.Connect(ep);
        }


        int fps = 0;
        void worker_RunWorkerCompleted(object sender, RunWorkerCompletedEventArgs e)
        {
            if (e.Cancelled) ;

            else if (e.Error != null)
            {
                Debug.WriteLine("Error while performing background operation.");
            }
            else
            {
                Debug.WriteLine("Everything complete");
            }
        }

        void worker_ProgressChanged(object sender, ProgressChangedEventArgs e)
        {
            force.SetForce(resp);

            fps++;
            ProcessForce();
        }

        void worker_doWork(object sender, DoWorkEventArgs e)
        {
            while (true)
            {
                Thread.Sleep(1);
                GetFrame();
                worker.ReportProgress(1);
                if (worker.CancellationPending)
                {
                    e.Cancel = true;
                    worker.ReportProgress(0);
                    return;
                }
            }
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            if (!workerOn)
            {
                workerOn = true;
                worker.RunWorkerAsync();
            }
        }

        UdpClient client;
        private void GetFrame()
        {
            byte[] request = new byte[8];
            request[0] = 0x12;
            request[1] = 0x34;
            request[2] = 0x00;
            request[3] = 0x02;
            request[4] = 0x00;
            request[5] = 0x00;
            request[6] = 0x00;
            request[7] = 0x01;

            client.Send(request, 8);
            var receivedData = client.Receive(ref ep);

            for (int i = 0; i < 6; i++)
            {
                var data = receivedData.Skip(12 + i * 4).Take(4).ToArray();
                resp.FTData[i] = BitConverter.ToInt32(data.Reverse().ToArray(), 0);
            }
        }

        private void stopButton_Click(object sender, RoutedEventArgs e)
        {
            workerOn = false;
            worker.CancelAsync();
        }

        private void calButton_Click(object sender, RoutedEventArgs e)
        {
            resp.SetBG();
        }


        private void Window_Loaded(object sender, RoutedEventArgs e)
        {

            DispatcherTimer UITimer = new DispatcherTimer();
            UITimer.Interval = TimeSpan.FromMilliseconds(16);
            UITimer.Tick += UITimer_Tick;
            UITimer.Start();

            DispatcherTimer FPSTimer = new DispatcherTimer();
            FPSTimer.Interval = TimeSpan.FromMilliseconds(1000);
            FPSTimer.Tick += FPSTimer_Tick;
            FPSTimer.Start();
        }

        private void UITimer_Tick(object sender, EventArgs e)
        {
            f1.Text = force.fx.ToString("0.00");
            f2.Text = force.fy.ToString("0.00");
            f3.Text = force.fz.ToString("0.00");

            // Update cursors
            double forceScale = forcePanel.Width / 2;
            double forceX = forcePanel.Width / 2 + force.fx * forceScale + forcePanel.Margin.Left - forceCursor.Width / 2;
            double forceY = forcePanel.Height / 2 + (0 - force.fy) * forceScale + forcePanel.Margin.Top - forceCursor.Height / 2;
            forceCursor.Margin = new Thickness(forceX, forceY, 0, 0);

            double hapticX = forcePanel.Width / 2 + hapticForce.fx * forceScale + forcePanel.Margin.Left - hapticCursor.Width / 2;
            double hapticY = forcePanel.Height / 2 + (0 - hapticForce.fy) * forceScale + forcePanel.Margin.Top - hapticCursor.Height / 2;
            hapticCursor.Margin = new Thickness(hapticX, hapticY, 0, 0);
        }

        private void FPSTimer_Tick(object sender, EventArgs e)
        {
            fpsBox.Content = fps.ToString();
            fps = 0;
        }

        double length = 0;
        double stopValue = 0.1;
        Point bend;
        private void ProcessForce()
        {
            if (!freeze) {
                if (!messageExists && !missedCallsExist && !newEmails && !itemsInSchedule)
                {
                    hapticForce = new Force(selectedFrictionValue, true);
                    return;
                }
                if (!messageExists && force.fx < 0 - stopValue ||
                    !missedCallsExist && force.fx > stopValue ||
                    !newEmails && force.fy < 0 - stopValue ||
                    !itemsInSchedule && force.fy > stopValue) {
                    hapticForce = new Force(selectedFrictionValue, true);
                    return;
                }
                hapticForce = force;
                length = force.fz;
                bend = new Point(force.fx, force.fy);
            }

            if (actuator.IsOpen)
            {
                double dx = bend.X - lastBend.X;
                double dy = bend.Y - lastBend.Y;
                double dist = Math.Sqrt(dx * dx + dy * dy);
                dist = dist / selectedFrictionValue;
                double bendMag = Math.Sqrt(bend.X * bend.X + bend.Y * bend.Y);

                if (bendMag < bendBottomOutThresh && !forceIsOutOfBounds() && !CheckIfWallsHit())
                {
                    bendBottomOut = false;
                    if (dist > bendThresh)
                    {
                       // EncodeTactilePatterns();
                        PlayGrain();
                        lastBend = new Point(bend.X, bend.Y);
                    }
                }
                else
                {
                    if (!bendBottomOut)
                    {
                        bendBottomOut = true;
                        PlayBottomOut();
                    }
                }
            }
        }

        private void EncodeTactilePatterns()
        {
            if (messageExists && force.fx < 0) 
            {
                if (force.fx > -0.2)
                {
                    UpdateSelectedFrictionValue(1);
                } else if (force.fx < -0.2 && force.fx > -0.6)
                {
                    UpdateSelectedFrictionValue(3);
                } else
                {
                    PlayBottomOut();
                    UpdateSelectedFrictionValue(1);
                }
            }
        }

        private void UpdateSelectedFrictionValue(int newValue)
        {
            selectedFrictionValue = newValue;
            force = new Force(selectedFrictionValue, false);
            hapticForce = force;
        }

        SerialPort actuator = new SerialPort();
        private void serialBtn_Click(object sender, RoutedEventArgs e)
        {
            actuator.BaudRate = 230400;
            actuator.PortName = portBox.Text;
            actuator.Open();
            if (actuator.IsOpen)
            {
                serialButton.Background = Brushes.Green;
            }
        }

        private bool CheckIfWallsHit()
        {
            return force.fx <= -1 || force.fx >= 1 || force.fy <= -1 || force.fy >= 1;
        }

        private bool forceIsOutOfBounds()
        {
            if (!CheckIfWallsHit())
            {
                bendBottomOut = false;
            }
            if (force.fx < -0.5 || force.fx > 0.5) {
                hapticForce.fx = force.fx;
                if (force.fy <= -0.5 || force.fy >= 0.5)
                {
                    hapticForce.fy = hapticForce.fy < -0.5 ? -0.5 : (hapticForce.fy > 0.5 ? 0.5 : hapticForce.fy);
                    return true;
                }
            }
            if (force.fy <= -0.5 || force.fy >= 0.5)
            {
                hapticForce.fy = force.fy;
                if (force.fx <= -0.5 || force.fx >= 0.5)
                {
                    hapticForce.fx = hapticForce.fx < -0.5 ? -0.5 : (hapticForce.fx > 0.5 ? 0.5 : hapticForce.fx);
                    return true;
                }
            }
            return false;
        }

        private void PlayBottomOut()
        {
            actuator.Write("b");
        }

        private void PlayGrain()
        {
            actuator.Write("a");
        }

        Point lastBend;
        double bendThresh = 0.1;
        private void setButton_Click(object sender, RoutedEventArgs e)
        {
            bendThresh = double.Parse(bendThreshBox.Text);
            lastBend = new Point(0, 0);

            bendBottomOutThresh = double.Parse(bendLimitBox.Text);
        }

        bool freeze = false;
        private void sendCheck_Checked(object sender, RoutedEventArgs e)
        {
            freeze = true;
        }

        private void sendCheck_Unchecked(object sender, RoutedEventArgs e)
        {
            freeze = false;
        }
        private void paramCheckChanged(object sender, RoutedEventArgs e)
        {
            if (sender == unreadMessages) {
                messageExists = unreadMessages.IsChecked.Value;
            }
            else if (sender == missedCalls)
            {
                missedCallsExist = missedCalls.IsChecked.Value;
            }
            else if (sender == unreadEmails)
            {
                newEmails = unreadEmails.IsChecked.Value;
            }
            else if (sender == eventsExist)
            {
                itemsInSchedule = eventsExist.IsChecked.Value;
            }
        }

        private void Slider_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
        {
            frictionLabel.Content = ((System.Windows.Controls.Slider)sender).Value.ToString("0");
        } 

        private void Set_Friction(object sender, RoutedEventArgs e)
        {
            UpdateSelectedFrictionValue(Int32.Parse((string)(frictionLabel.Content)));
        }

        private void bendThreshBox_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {

        }
    }

    class Force
    {
        static double cntPerForce = 4448221.5;

        public double fx, fy, fz;
        public int selectedFrictionValue;
        public bool noHapticFeedback;
        public Force(int selectedFrictionValue, bool noForce)
        {
            this.selectedFrictionValue = selectedFrictionValue;
            this.noHapticFeedback = noForce;
            fx = 0; fy = 0; fz = 0;
        }
        public void SetForce(Response resp)
        {
            if (noHapticFeedback)
            {
                return;
            }
            fx = 0 - (fx + Utils.lbToN(resp.GetData(1) / cntPerForce)) / (2 * this.selectedFrictionValue);
            fy = 0 - (fy + Utils.lbToN(resp.GetData(0) / cntPerForce)) / (2 * this.selectedFrictionValue);
            fz = 0 - (fz + Utils.lbToN(resp.GetData(2) / cntPerForce)) / (2 * this.selectedFrictionValue);
            CheckBoundaries();
        }

        public void CheckBoundaries() {
           /* if (fx < -0.5 || fx > 0.5) {
                if (fy < -0.5)
                {
                    fy = -0.5;
                }
                if (fy > 0.5)
                {
                    fy = 0.5;
                }
            }
            if (fy < -0.5 || fy > 0.5)
            {
                if (fx < -0.5)
                {
                    fx = -0.5;
                }
                if (fx > 0.5)
                {
                    fx = 0.5;
                }
            }*/
            fx = fx < -1 ? -1 : (fx > 1 ? 1 : fx);
            fy = fy < -1 ? -1 : (fy > 1 ? 1 : fy);
        }
    }

    class Response
    {
        public Int32[] FTData;
        public Int32[] FTbackground;

        public Response()
        {
            FTData = new Int32[6];
            FTbackground = new Int32[6];
        }
        public void SetBG()
        {
        for (int i = 0; i < 6; i++)
                FTbackground[i] = FTData[i];
        }
        public Int32 GetData(int i)
        {            
            return FTData[i] - FTbackground[i];
        }
    }
}
